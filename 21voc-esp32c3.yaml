esphome:
  name: 21voc-esp32c3
  friendly_name: "21VOC-Temperature-Humidity ESP32-C3 Sensor"

esp32:
  board: airm2m_core_esp32c3
  framework:
    type: arduino

# ä»secrets.yamlæ–‡ä»¶ä¸­è¯»å–WiFié…ç½®
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  # WiFiè¿æ¥å¤±è´¥æ—¶çš„å¤„ç†
  ap:
    ssid: "ESP32C3-21VOC Fallback Hotspot"
    password: "12345678"

  # WiFiè¿æ¥çŠ¶æ€å›è°ƒ
  on_connect:
    - logger.log: "WiFiè¿æ¥æˆåŠŸï¼"
  on_disconnect:
    - logger.log: "WiFiè¿æ¥æ–­å¼€ï¼"

# UARTé…ç½® - ç”¨äºè¯»å–21VOCä¼ æ„Ÿå™¨æ•°æ®
uart:
  id: uart_bus
  tx_pin: GPIO0  # TXå¼•è„š - æ¥ä¼ æ„Ÿå™¨RX
  rx_pin: GPIO1  # RXå¼•è„š - æ¥ä¼ æ„Ÿå™¨TX
  baud_rate: 9600  # 21VOCä¼ æ„Ÿå™¨æ³¢ç‰¹ç‡
  data_bits: 8
  parity: NONE
  stop_bits: 1
  rx_buffer_size: 512

# å…¨å±€å˜é‡å­˜å‚¨21VOCä¼ æ„Ÿå™¨æ•°æ®å’Œä¸Šæ¬¡æ•°å€¼
globals:
  - id: last_voc
    type: float
    restore_value: no
    initial_value: '-999.0'
  - id: last_ch2o
    type: float
    restore_value: no
    initial_value: '-999.0'
  - id: last_eco2
    type: float
    restore_value: no
    initial_value: '-999.0'
  - id: last_temperature
    type: float
    restore_value: no
    initial_value: '-999.0'
  - id: last_humidity
    type: float
    restore_value: no
    initial_value: '-999.0'
  - id: last_air_quality
    type: std::string
    restore_value: no
    initial_value: '"æœªçŸ¥"'

sensor:
  # 21VOCä¼ æ„Ÿå™¨æ•°æ®
  - platform: template
    name: "VOC"
    id: sensor_voc
    unit_of_measurement: "Î¼g/mÂ³"
    accuracy_decimals: 0
    state_class: "measurement"
    icon: "mdi:chemical-weapon"

  - platform: template
    name: "Formaldehyde (CHâ‚‚O)"
    id: sensor_ch2o
    unit_of_measurement: "Î¼g/mÂ³"
    accuracy_decimals: 0
    state_class: "measurement"
    icon: "mdi:molecule"

  - platform: template
    name: "eCO2"
    id: sensor_eco2
    unit_of_measurement: "ppm"
    accuracy_decimals: 0
    state_class: "measurement"
    icon: "mdi:molecule-co2"

  - platform: template
    name: "Temperature"
    id: sensor_temperature
    unit_of_measurement: "Â°C"
    accuracy_decimals: 1
    state_class: "measurement"
    device_class: "temperature"
    icon: "mdi:thermometer"

  - platform: template
    name: "Humidity"
    id: sensor_humidity
    unit_of_measurement: "%"
    accuracy_decimals: 1
    state_class: "measurement"
    device_class: "humidity"
    icon: "mdi:water-percent"

  # ESP32-C3å†…éƒ¨æ¸©åº¦ä¼ æ„Ÿå™¨ (ç”¨äºå¯¹æ¯”)
  - platform: internal_temperature
    name: "ESP32-C3 Internal Temperature"
    update_interval: 60s

# 21VOCä¼ æ„Ÿå™¨æ•°æ®å¤„ç†é—´éš” - åŸºäºä½ çš„C++ä»£ç å®ç°
interval:
  - interval: 2000ms  # æ¯2ç§’æ£€æŸ¥ä¸€æ¬¡UARTæ•°æ®
    then:
      - lambda: |-
          ESP_LOGI("21voc_uart", "â° å¼€å§‹è¯»å–21VOCä¼ æ„Ÿå™¨æ•°æ®");

          // æ¸…ç©ºæ¥æ”¶ç¼“å†²åŒºä¸­çš„æ—§æ•°æ®
          int cleared = 0;
          uint8_t dummy_buffer[1];
          while (id(uart_bus).available()) {
            if (id(uart_bus).read_array(dummy_buffer, 1) > 0) {
              cleared++;
            }
            delay(1);
          }
          if (cleared > 0) {
            ESP_LOGI("21voc_uart", "æ¸…ç©ºäº†%då­—èŠ‚æ—§æ•°æ®", cleared);
          }

          // ç­‰å¾…æ•°æ®åˆ°è¾¾ï¼Œè¶…æ—¶2ç§’
          uint8_t buffer[64];
          int bytesRead = 0;
          unsigned long startTime = millis();

          while (bytesRead < 64 && (millis() - startTime) < 2000) {
            if (id(uart_bus).available()) {
              uint8_t single_byte[1];
              if (id(uart_bus).read_array(single_byte, 1) > 0) {
                buffer[bytesRead] = single_byte[0];
                bytesRead++;
              }

              // å¦‚æœè¿ç»­æ²¡æœ‰æ–°æ•°æ®è¶…è¿‡100msï¼Œè®¤ä¸ºä¸€å¸§æ•°æ®æ¥æ”¶å®Œæˆ
              unsigned long lastByteTime = millis();
              while (!id(uart_bus).available() && (millis() - lastByteTime) < 100) {
                delay(5);
              }
              if (!id(uart_bus).available()) {
                break;
              }
            }
            delay(10);
          }

          if (bytesRead > 0) {
            // è°ƒè¯•ï¼šæ˜¾ç¤ºæ¥æ”¶åˆ°çš„åŸå§‹æ•°æ®
            ESP_LOGI("21voc_uart", "ğŸ“¡ æ¥æ”¶åˆ° %d å­—èŠ‚:", bytesRead);
            std::string hex_data = "";
            for (int i = 0; i < bytesRead; i++) {
              char hex_str[4];
              sprintf(hex_str, "%02X ", buffer[i]);
              hex_data += hex_str;
            }
            ESP_LOGI("21voc_uart", "åŸå§‹æ•°æ®: %s", hex_data.c_str());

            // è§£æ21VOCæ•°æ® - ä¸¥æ ¼æŒ‰ç…§ä½ çš„C++ä»£ç çš„parse21VOCDataå‡½æ•°
            ESP_LOGI("21voc_uart", "ğŸ” è§£æ21VOCæ•°æ®: é•¿åº¦=%d", bytesRead);

            // æ£€æŸ¥æ•°æ®å¸§é•¿åº¦ (éœ€è¦12å­—èŠ‚)
            if (bytesRead < 12) {
              ESP_LOGW("21voc_uart", "æ•°æ®é•¿åº¦ä¸è¶³ï¼ˆéœ€è¦12å­—èŠ‚ï¼Œå®é™…%då­—èŠ‚ï¼‰", bytesRead);
              return;
            }

            // å¯»æ‰¾æ­£ç¡®çš„æ•°æ®å¸§èµ·å§‹ä½ç½® (0x2Cå¼€å¤´)
            int frameStart = -1;
            for (int i = 0; i <= bytesRead - 12; i++) {
              if (buffer[i] == 0x2C) {
                frameStart = i;
                ESP_LOGI("21voc_uart", "æ‰¾åˆ°å¸§å¤´0x2Cåœ¨ä½ç½®%d", i);
                break;
              }
            }

            if (frameStart == -1) {
              ESP_LOGW("21voc_uart", "æœªæ‰¾åˆ°å¸§å¤´0x2C");
              // å°è¯•å…¶ä»–å¯èƒ½çš„å¸§å¤´
              for (int i = 0; i <= bytesRead - 12; i++) {
                if (buffer[i] == 0xFF || buffer[i] == 0x42 || buffer[i] == 0x4D) {
                  ESP_LOGW("21voc_uart", "å‘ç°å¯èƒ½çš„å¸§å¤´0x%02Xåœ¨ä½ç½®%d", buffer[i], i);
                }
              }
              return;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å­—èŠ‚
            if (frameStart + 12 > bytesRead) {
              ESP_LOGW("21voc_uart", "å¸§åæ•°æ®ä¸è¶³");
              return;
            }

            // æå–12å­—èŠ‚æ•°æ®å¸§
            uint8_t frame[12];
            for (int i = 0; i < 12; i++) {
              frame[i] = buffer[frameStart + i];
            }

            ESP_LOGI("21voc_uart", "å®Œæ•´å¸§æ•°æ®: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
                     frame[0], frame[1], frame[2], frame[3], frame[4], frame[5],
                     frame[6], frame[7], frame[8], frame[9], frame[10], frame[11]);

            // æ ¡éªŒå’Œè®¡ç®— - æŒ‰ç…§ä½ çš„C++ä»£ç 
            uint8_t checksum = 0;
            for (int i = 0; i < 11; i++) {
              checksum += frame[i];
            }
            checksum = (~checksum) + 1;

            ESP_LOGI("21voc_uart", "è®¡ç®—æ ¡éªŒå’Œ: 0x%02X, æ¥æ”¶æ ¡éªŒå’Œ: 0x%02X", checksum, frame[11]);

            // éªŒè¯æ ¡éªŒå’Œ
            if (frame[11] != checksum) {
              ESP_LOGW("21voc_uart", "æ ¡éªŒå’Œä¸åŒ¹é…ï¼Œä½†ç»§ç»­è§£æ");
            } else {
              ESP_LOGI("21voc_uart", "æ ¡éªŒå’Œæ­£ç¡®");
            }

            // æŒ‰ç…§åè®®è§£ææ•°æ®
            uint16_t voc_ugm3 = frame[1] * 256 + frame[2];
            uint16_t ch2o_ugm3 = frame[3] * 256 + frame[4];
            uint16_t eco2_ppm = frame[5] * 256 + frame[6];

            // æ¸©åº¦è§£æ
            uint16_t temp_raw = frame[7] * 256 + frame[8];
            float temperature_c;
            if (temp_raw > 0x8000) {
              temp_raw = 0x10000 - temp_raw;
              temperature_c = -(float)temp_raw * 0.1;
            } else {
              temperature_c = (float)temp_raw * 0.1;
            }

            // æ¹¿åº¦è§£æ
            uint16_t humidity_raw = frame[9] * 256 + frame[10];
            float humidity_rh = (float)humidity_raw * 0.1;

            ESP_LOGI("21voc_uart", "è§£æç»“æœ: VOC=%d, CH2O=%d, eCO2=%d, æ¸©åº¦=%.1f, æ¹¿åº¦=%.1f",
                     voc_ugm3, ch2o_ugm3, eco2_ppm, temperature_c, humidity_rh);

            // æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥
            bool data_valid = true;

            // åˆç†æ€§æ£€æŸ¥ (æ ¹æ®ä¼ æ„Ÿå™¨è§„æ ¼)
            if (voc_ugm3 > 60000) {  // VOCé€šå¸¸ä¸ä¼šè¶…è¿‡60000 Î¼g/mÂ³
              ESP_LOGW("21voc_uart", "âŒ VOCæ•°å€¼å¼‚å¸¸: %d Î¼g/mÂ³", voc_ugm3);
              data_valid = false;
            }
            if (ch2o_ugm3 > 5000) {  // ç”²é†›é€šå¸¸ä¸ä¼šè¶…è¿‡5000 Î¼g/mÂ³
              ESP_LOGW("21voc_uart", "âŒ ç”²é†›æ•°å€¼å¼‚å¸¸: %d Î¼g/mÂ³", ch2o_ugm3);
              data_valid = false;
            }
            if (eco2_ppm > 10000) {  // eCO2é€šå¸¸ä¸ä¼šè¶…è¿‡10000 ppm
              ESP_LOGW("21voc_uart", "âŒ eCO2æ•°å€¼å¼‚å¸¸: %d ppm", eco2_ppm);
              data_valid = false;
            }
            if (temperature_c < -40.0 || temperature_c > 85.0) {  // æ¸©åº¦èŒƒå›´æ£€æŸ¥
              ESP_LOGW("21voc_uart", "âŒ æ¸©åº¦æ•°å€¼å¼‚å¸¸: %.1fÂ°C", temperature_c);
              data_valid = false;
            }
            if (humidity_rh < 0.0 || humidity_rh > 100.0) {  // æ¹¿åº¦èŒƒå›´æ£€æŸ¥
              ESP_LOGW("21voc_uart", "âŒ æ¹¿åº¦æ•°å€¼å¼‚å¸¸: %.1f%%", humidity_rh);
              data_valid = false;
            }

            if (data_valid) {
              ESP_LOGI("21voc_uart", "ğŸ“Š === 21VOCä¼ æ„Ÿå™¨è¯»æ•° ===");
              ESP_LOGI("21voc_uart", "â° æ—¶é—´æˆ³: %lu ms", millis());

              // å‘å¸ƒVOCæ•°æ®
              if (id(last_voc) == -999.0 || abs((float)voc_ugm3 - id(last_voc)) >= 1.0) {
                ESP_LOGI("21voc_uart", "âœ… å‘å¸ƒVOC: %d Î¼g/mÂ³", voc_ugm3);
                id(sensor_voc).publish_state(voc_ugm3);
                id(last_voc) = voc_ugm3;
              }

              // å‘å¸ƒç”²é†›æ•°æ®
              if (id(last_ch2o) == -999.0 || abs((float)ch2o_ugm3 - id(last_ch2o)) >= 1.0) {
                ESP_LOGI("21voc_uart", "âœ… å‘å¸ƒç”²é†›: %d Î¼g/mÂ³", ch2o_ugm3);
                id(sensor_ch2o).publish_state(ch2o_ugm3);
                id(last_ch2o) = ch2o_ugm3;
              }

              // å‘å¸ƒeCO2æ•°æ®
              if (id(last_eco2) == -999.0 || abs((float)eco2_ppm - id(last_eco2)) >= 1.0) {
                ESP_LOGI("21voc_uart", "âœ… å‘å¸ƒeCO2: %d ppm", eco2_ppm);
                id(sensor_eco2).publish_state(eco2_ppm);
                id(last_eco2) = eco2_ppm;
              }

              // å‘å¸ƒæ¸©åº¦æ•°æ®
              if (id(last_temperature) == -999.0 || abs(temperature_c - id(last_temperature)) >= 0.1) {
                ESP_LOGI("21voc_uart", "âœ… å‘å¸ƒæ¸©åº¦: %.1fÂ°C", temperature_c);
                id(sensor_temperature).publish_state(temperature_c);
                id(last_temperature) = temperature_c;
              }

              // å‘å¸ƒæ¹¿åº¦æ•°æ®
              if (id(last_humidity) == -999.0 || abs(humidity_rh - id(last_humidity)) >= 0.1) {
                ESP_LOGI("21voc_uart", "âœ… å‘å¸ƒæ¹¿åº¦: %.1f%%", humidity_rh);
                id(sensor_humidity).publish_state(humidity_rh);
                id(last_humidity) = humidity_rh;
              }

              // ç©ºæ°”è´¨é‡è¯„ä¼°é€»è¾‘ (åŸºäºVOCå’Œç”²é†›)
              std::string air_quality = "ä¼˜ç§€";
              int quality_score = 0;

              // VOCè¯„ä¼° (Î¼g/mÂ³) - æ ¹æ®WHOæ ‡å‡†
              if (voc_ugm3 <= 300) {
                quality_score += 1; // ä¼˜ç§€
              } else if (voc_ugm3 <= 600) {
                quality_score += 2; // è‰¯å¥½
              } else if (voc_ugm3 <= 1000) {
                quality_score += 3; // ä¸­ç­‰
              } else if (voc_ugm3 <= 3000) {
                quality_score += 4; // è¾ƒå·®
              } else {
                quality_score += 5; // å¾ˆå·®
              }

              // ç”²é†›è¯„ä¼° (Î¼g/mÂ³) - æ ¹æ®WHOæ ‡å‡†
              if (ch2o_ugm3 <= 80) {
                quality_score += 1; // ä¼˜ç§€
              } else if (ch2o_ugm3 <= 100) {
                quality_score += 2; // è‰¯å¥½
              } else if (ch2o_ugm3 <= 300) {
                quality_score += 3; // ä¸­ç­‰
              } else if (ch2o_ugm3 <= 500) {
                quality_score += 4; // è¾ƒå·®
              } else {
                quality_score += 5; // å¾ˆå·®
              }

              // æ ¹æ®ç»¼åˆè¯„åˆ†ç¡®å®šç©ºæ°”è´¨é‡ç­‰çº§ (æ€»åˆ†2-10)
              if (quality_score <= 3) {
                air_quality = "ä¼˜ç§€";
              } else if (quality_score <= 5) {
                air_quality = "è‰¯å¥½";
              } else if (quality_score <= 7) {
                air_quality = "ä¸­ç­‰";
              } else if (quality_score <= 9) {
                air_quality = "è¾ƒå·®";
              } else {
                air_quality = "å¾ˆå·®";
              }

              ESP_LOGI("21voc_uart", "ğŸŒŸ ç©ºæ°”è´¨é‡è¯„ä¼°: %s (è¯„åˆ†: %d)", air_quality.c_str(), quality_score);
              ESP_LOGI("21voc_uart", "   VOC: %d Î¼g/mÂ³, ç”²é†›: %d Î¼g/mÂ³", voc_ugm3, ch2o_ugm3);

              // å‘å¸ƒç©ºæ°”è´¨é‡è¯„ä¼°
              if (id(last_air_quality) != air_quality) {
                ESP_LOGI("21voc_uart", "âœ… å‘å¸ƒç©ºæ°”è´¨é‡: %s", air_quality.c_str());
                id(air_quality_status).publish_state(air_quality);
                id(last_air_quality) = air_quality;
              }

              ESP_LOGI("21voc_uart", "===============================");
              ESP_LOGI("21voc_uart", "âœ… æ•°æ®è¯»å–å’Œå¤„ç†å®Œæˆ");
            } else {
              ESP_LOGW("21voc_uart", "âš ï¸ æ¥æ”¶åˆ°æ•°æ®ä½†éªŒè¯å¤±è´¥");
            }
          } else {
            ESP_LOGW("21voc_uart", "â° è¶…æ—¶ï¼Œæœªæ¥æ”¶åˆ°æ•°æ®");
          }

# æ–‡æœ¬ä¼ æ„Ÿå™¨
text_sensor:
  # WiFiä¿¡æ¯
  - platform: wifi_info
    mac_address:
      name: "Mac Address"

  # ç©ºæ°”è´¨é‡è¯„ä¼°
  - platform: template
    name: "Air Quality Assessment"
    id: air_quality_status
    icon: "mdi:air-filter"

# äºŒè¿›åˆ¶ä¼ æ„Ÿå™¨
binary_sensor:
  # è®¾å¤‡çŠ¶æ€
  - platform: status
    name: "Status"

# å¼€å…³æ§åˆ¶
switch:
  # é‡å¯å¼€å…³
  - platform: restart
    name: "Restart"

# æ—¥å¿—é…ç½®
logger:
  baud_rate: 115200
  level: INFO  # æ˜¾ç¤ºä¼ æ„Ÿå™¨æ•°æ®
  logs:
    21voc_uart: INFO    # æ˜¾ç¤º21VOCä¼ æ„Ÿå™¨æ•°æ®
    uart_debug: WARN    # å‡å°‘UARTè°ƒè¯•ä¿¡æ¯
    uart: WARN          # å‡å°‘UARTæ—¥å¿—
    wifi: WARN          # å‡å°‘WiFiæ—¥å¿—
    api: WARN           # å‡å°‘APIæ—¥å¿—
    ota: WARN           # å‡å°‘OTAæ—¥å¿—
    web_server: WARN    # å‡å°‘WebæœåŠ¡å™¨æ—¥å¿—

# OTAæ›´æ–°
ota:
  platform: esphome

# APIé…ç½®
api:

# WebæœåŠ¡å™¨
web_server:
  port: 80
  auth:
    username: admin
    password: !secret wifi_password

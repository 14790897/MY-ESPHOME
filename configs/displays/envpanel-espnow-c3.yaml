# ========= ESP-NOW接收器 + 显示面板（ESP32-C3定制版）=========
substitutions:
  device_name: "envpanel-espnow-c3"
  friendly_name: "ESP-NOW-C3"
  
time:
  - platform: sntp
    id: sntp_time
    servers:
      - ntp.aliyun.com
      - time.windows.com
    timezone: Asia/Shanghai

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  # on_boot:
  #   priority: -10
  #   then:
  #     - delay: 8s         # 等 Wi-Fi + SNTP
  #     - mqtt.enable:

esp32:
  board: airm2m_core_esp32c3
  framework:
    type: esp-idf

logger:
  level: debug
api:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # 如果连接失败，就自动开启 AP 热点
  ap:
    ssid: "My-ESPHome-AP"
    password: "12345678"
captive_portal:

ota:
  - platform: esphome

# MQTT配置
mqtt:
  broker: !secret mqtt_broker
  port: 8883
  username: !secret mqtt_username
  password: !secret mqtt_password
  client_id: !secret mqtt_topic_device_name
  # clean_session: true             # 必须为 true，否则可能被服务器直接断开
  # topic_prefix: null
  # enable_on_boot: false
  # discovery: false
  # discovery_retain: false
  # skip_cert_cn_check: true
  # idf_send_async: false  # 关键：ESP-IDF同步发送，避免TLS握手问题
  certificate_authority: !secret certificate
  # keepalive: 60s
  # reboot_timeout: 15min
  # MQTT连接状态回调
  on_connect:
    - lambda: |-
        ESP_LOGI("mqtt", "MQTT连接成功！");
        id(mqtt_connected) = true;
  on_disconnect:
    - lambda: |-
        ESP_LOGW("mqtt", "MQTT断开连接！");
        id(mqtt_connected) = false;
  # 订阅MQTT主题获取响应信息
  on_message:
    - topic: !secret mqtt_topic_property_set  # 订阅设备属性设置主题
      then:
        - lambda: |-
            ESP_LOGI("mqtt_response", "收到MQTT属性设置消息: %s", x.c_str());
            // 可以在这里解析JSON响应并执行相应操作
            id(last_mqtt_response) = x;
            id(mqtt_response_sensor).publish_state(x);
    - topic: !secret mqtt_topic_service_invoke  # 订阅服务调用主题
      then:
        - lambda: |-
            ESP_LOGI("mqtt_response", "收到MQTT服务调用消息: %s", x.c_str());
            id(last_mqtt_response) = x;
            id(mqtt_response_sensor).publish_state(x);
    - topic: !secret mqtt_topic_response  # 订阅通用响应主题
      then:
        - lambda: |-
            ESP_LOGI("mqtt_response", "收到MQTT响应: %s", x.c_str());
            id(last_mqtt_response) = x;
            id(mqtt_response_sensor).publish_state(x);
            
            // 解析响应代码
            if (x.find("\"code\":200") != std::string::npos) {
              ESP_LOGI("mqtt_response", "✓ 数据上传成功");
            } else if (x.find("\"code\":") != std::string::npos) {
              ESP_LOGW("mqtt_response", "✗ 数据上传失败");
            }


espnow:
  id: espnow_component
  enable_on_boot: true
  channel: 1
  auto_add_peer: true
  on_broadcast:
    then:
      - lambda: |-
          ESP_LOGD("espnow", "Received ESP-NOW data (%u bytes)", size);

          if (size == 0) {
            ESP_LOGW("espnow", "Empty payload received");
            return;
          }

          if (data[0] == '{' && data[size - 1] == '}') {
            std::string json_payload(reinterpret_cast<const char *>(data), size);

            auto extract_float = [&](const char *field, float &out) -> bool {
              const std::string needle = std::string("\"") + field + "\"";
              size_t pos = json_payload.find(needle);
              if (pos == std::string::npos) {
                return false;
              }
              pos = json_payload.find(':', pos + needle.size());
              if (pos == std::string::npos) {
                return false;
              }
              const char *start = json_payload.c_str() + pos + 1;
              char *end = nullptr;
              out = strtof(start, &end);
              return start != end;
            };

            bool any_valid = false;

            float tvoc = NAN;
            if (extract_float("tvoc", tvoc)) {
              if (!isnan(tvoc) && tvoc >= 0.0f && tvoc < 10.0f) {
                id(received_tvoc) = tvoc;
                id(espnow_tvoc).publish_state(tvoc);
                any_valid = true;
                ESP_LOGI("espnow", "TVOC=%.3f mg/m³", tvoc);
              } else {
                ESP_LOGW("espnow", "TVOC value out of range: %.3f", tvoc);
              }
            }

            float formaldehyde = NAN;
            if (extract_float("formaldehyde", formaldehyde)) {
              if (!isnan(formaldehyde) && formaldehyde >= 0.0f && formaldehyde < 1.5f) {
                id(received_formaldehyde) = formaldehyde;
                id(espnow_formaldehyde).publish_state(formaldehyde);
                any_valid = true;
                ESP_LOGI("espnow", "甲醛=%.3f mg/m³", formaldehyde);
              } else {
                ESP_LOGW("espnow", "甲醛数值超出范围: %.3f", formaldehyde);
              }
            }

            float co2 = NAN;
            if (extract_float("co2", co2)) {
              if (!isnan(co2) && co2 >= 0.0f && co2 < 10000.0f) {
                id(received_co2) = co2;
                id(espnow_co2).publish_state(co2);
                any_valid = true;
                ESP_LOGI("espnow", "CO₂=%.3f", co2);
              } else {
                ESP_LOGW("espnow", "CO₂数值超出范围: %.3f", co2);
              }
            }

            if (any_valid) {
              const unsigned long now = millis();
              id(last_voc_update_time) = now;
              id(last_update_time) = now;
            } else {
              ESP_LOGW("espnow", "JSON payload did not contain valid VOC data");
            }
            return;
          }

          if (size < 12) {
            ESP_LOGW("espnow", "Payload too short: %u bytes", size);
            return;
          }

          float temp = NAN;
          float hum = NAN;
          float press = NAN;
          float tvoc = NAN;
          float formaldehyde = NAN;
          float co2 = NAN;

          memcpy(&temp, data, 4);
          memcpy(&hum, data + 4, 4);
          memcpy(&press, data + 8, 4);

          if (size >= 24) {
            memcpy(&tvoc, data + 12, 4);
            memcpy(&formaldehyde, data + 16, 4);
            memcpy(&co2, data + 20, 4);
          } else if (size > 12) {
            ESP_LOGW("espnow", "Unsupported payload length: %u bytes", size);
          }

          const bool base_valid =
              (temp > -50.0f && temp < 100.0f) &&
              (hum >= 0.0f && hum <= 100.0f) &&
              (press > 800.0f && press < 1200.0f);

          if (!base_valid) {
            ESP_LOGW("espnow", "Base payload validation failed: T=%.2f, H=%.2f, P=%.2f", temp, hum, press);
            return;
          }

          const bool tvoc_valid = !isnan(tvoc) && tvoc >= 0.0f && tvoc < 10.0f;
          const bool hcho_valid = !isnan(formaldehyde) && formaldehyde >= 0.0f && formaldehyde < 1.5f;
          const bool co2_valid = !isnan(co2) && co2 >= 200.0f && co2 < 10000.0f;

          id(received_temperature) = temp;
          id(received_humidity) = hum;
          id(received_pressure) = press;
          if (tvoc_valid) {
            id(received_tvoc) = tvoc;
          }
          if (hcho_valid) {
            id(received_formaldehyde) = formaldehyde;
          }
          if (co2_valid) {
            id(received_co2) = co2;
          }

          const unsigned long now = millis();
          id(last_env_update_time) = now;
          id(last_update_time) = now;

          id(espnow_temperature).publish_state(temp);
          id(espnow_humidity).publish_state(hum);
          id(espnow_pressure).publish_state(press);
          if (tvoc_valid) {
            id(espnow_tvoc).publish_state(tvoc);
          }
          if (hcho_valid) {
            id(espnow_formaldehyde).publish_state(formaldehyde);
          }
          if (co2_valid) {
            id(espnow_co2).publish_state(co2);
          }

          ESP_LOGI("espnow", "Updated: T=%.1f°C, H=%.1f%%, P=%.1fhPa", temp, hum, press);
          if (tvoc_valid) {
            ESP_LOGI("espnow", "TVOC=%.3f mg/m³", tvoc);
          }
          if (hcho_valid) {
            ESP_LOGI("espnow", "甲醛=%.3f mg/m³", formaldehyde);
          }
          if (co2_valid) {
            ESP_LOGI("espnow", "CO₂=%.0f ppm", co2);
          }
globals:
  - id: received_temperature
    type: float
    initial_value: '0.0'
  - id: received_humidity
    type: float
    initial_value: '0.0'
  - id: received_pressure
    type: float
    initial_value: '0.0'
  - id: received_tvoc
    type: float
    initial_value: '0.0'
  - id: received_formaldehyde
    type: float
    initial_value: '0.0'
  - id: received_co2
    type: float
    initial_value: '0.0'
  - id: last_env_update_time
    type: unsigned long
    initial_value: '0'
  - id: last_voc_update_time
    type: unsigned long
    initial_value: '0'
  - id: last_update_time
    type: unsigned long
    initial_value: '0'
  # MQTT响应相关全局变量
  - id: last_mqtt_response
    type: std::string
    initial_value: '""'
  - id: mqtt_connected
    type: bool
    initial_value: 'false'

packages:
  display9341: !include ../displays/display9341-espnow.yaml

sensor:
  - platform: template
    name: "ESP-NOW Temperature"
    id: espnow_temperature
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    update_interval: never

  - platform: template
    name: "ESP-NOW Humidity"
    id: espnow_humidity
    unit_of_measurement: "%"
    device_class: humidity
    state_class: measurement
    accuracy_decimals: 1
    update_interval: never

  - platform: template
    name: "ESP-NOW Pressure"
    id: espnow_pressure
    unit_of_measurement: "hPa"
    device_class: atmospheric_pressure
    state_class: measurement
    accuracy_decimals: 1
    update_interval: never

  - platform: template
    name: "ESP-NOW TVOC"
    id: espnow_tvoc
    unit_of_measurement: "mg/m³"
    device_class: volatile_organic_compounds
    state_class: measurement
    accuracy_decimals: 3
    update_interval: never

  - platform: template
    name: "ESP-NOW 甲醛"
    id: espnow_formaldehyde
    unit_of_measurement: "mg/m³"
    state_class: measurement
    accuracy_decimals: 3
    update_interval: never

  - platform: template
    name: "ESP-NOW CO₂"
    id: espnow_co2
    unit_of_measurement: "ppm"
    device_class: carbon_dioxide
    state_class: measurement
    accuracy_decimals: 0
    update_interval: never

binary_sensor:
  - platform: template
    name: "ESP-NOW Data Fresh"
    id: data_fresh
    lambda: |-
      if (id(last_update_time) == 0) return false;
      return (millis() - id(last_update_time)) < 600000;
    filters:
      - delayed_on: 1s
      - delayed_off: 5s

text_sensor:
  - platform: template
    name: "ESP-NOW Status"
    id: espnow_status
    lambda: |-
      if (id(last_update_time) == 0) return std::string("等待数据");
      unsigned long age = (millis() - id(last_update_time)) / 1000;
      if (age < 60) return std::string("数据最新");
      if (age < 600) return std::string("数据已有 " + to_string(age) + " 秒");
      return std::string("数据超时");
    update_interval: 10s
  
  # MQTT响应信息传感器
  - platform: template
    name: "MQTT Response"
    id: mqtt_response_sensor
    icon: "mdi:message-reply-text"
    lambda: |-
      return id(last_mqtt_response);
    update_interval: never
  
  # MQTT连接状态传感器
  - platform: template
    name: "MQTT Connection Status"
    id: mqtt_status_sensor
    icon: "mdi:cloud-check"
    lambda: |-
      if (id(mqtt_connected)) {
        return std::string("已连接");
      } else {
        return std::string("未连接");
      }
    update_interval: 10s

# 定时上传MQTT数据 - 每60秒上传一次传感器数据到物联网平台
interval:
  - interval: 60s
    then:
      - if:
          condition:
            mqtt.connected:
          then:
            - mqtt.publish:
                topic: !secret mqtt_topic_property_post
                payload: !lambda |-
                  // 检查是否有有效数据
                  if (id(last_update_time) == 0) {
                    ESP_LOGW("mqtt_upload", "没有可用的传感器数据");
                    return std::string("");
                  }
                  
                  // 检查数据是否过期（超过10分钟）
                  unsigned long data_age = (millis() - id(last_update_time)) / 1000;
                  if (data_age > 600) {
                    ESP_LOGW("mqtt_upload", "传感器数据已过期 (%lu 秒)", data_age);
                    return std::string("");
                  }
                  
                  #include <ArduinoJson.h>
                  
                  ESP_LOGI("mqtt_upload", "上传传感器数据到MQTT物联网平台...");
                  
                  // 获取当前时间戳（Unix时间戳，纳秒）
                  auto time_now = id(sntp_time).now();
                  int64_t timestamp = time_now.timestamp * 1000000000LL;
                  
                  // 使用ArduinoJson构建JSON数据
                  JsonDocument doc;
                  
                  // 设置顶层字段
                  doc["id"] = to_string(millis());
                  doc["version"] = "1.0";
                  
                  // 创建params对象
                  JsonObject params = doc["params"].to<JsonObject>();
                  
                  // 添加temperature（必需）
                  JsonObject temp = params["temperature"].to<JsonObject>();
                  temp["value"] = id(received_temperature);
                  temp["time"] = timestamp;
                  
                  // 添加humidity（必需）
                  JsonObject hum = params["humidity"].to<JsonObject>();
                  hum["value"] = id(received_humidity);
                  hum["time"] = timestamp;
                  
                  // 添加pressure（必需）
                  JsonObject press = params["pressure"].to<JsonObject>();
                  press["value"] = id(received_pressure);
                  press["time"] = timestamp;
                  
                  // 添加TVOC数据（如果有效）
                  if (!isnan(id(received_tvoc)) && id(received_tvoc) > 0.0f) {
                    JsonObject tvoc = params["tvoc"].to<JsonObject>();
                    tvoc["value"] = id(received_tvoc);
                    tvoc["time"] = timestamp;
                  }
                  
                  // 添加甲醛数据（如果有效）
                  if (!isnan(id(received_formaldehyde)) && id(received_formaldehyde) > 0.0f) {
                    JsonObject hcho = params["formaldehyde"].to<JsonObject>();
                    hcho["value"] = id(received_formaldehyde);
                    hcho["time"] = timestamp;
                  }
                  
                  // 添加CO2数据（如果有效）
                  if (!isnan(id(received_co2)) && id(received_co2) > 0.0f) {
                    JsonObject co2 = params["co2"].to<JsonObject>();
                    co2["value"] = id(received_co2)*1000;  // 转换为ppm
                    co2["time"] = timestamp;
                  }
                  
                  // 序列化为字符串
                  std::string json_msg;
                  serializeJson(doc, json_msg);
                  
                  ESP_LOGI("mqtt_upload", "MQTT数据上传: %s", json_msg.c_str());
                  return json_msg;